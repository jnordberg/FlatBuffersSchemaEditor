/*
 * generated by Xtext
 */
package maxim.zaks.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import maxim.zaks.flatBuffers.AttributeName;
import maxim.zaks.flatBuffers.CustomAttributes;
import maxim.zaks.flatBuffers.FieldAttributes;
import maxim.zaks.flatBuffers.Fields;
import maxim.zaks.flatBuffers.FlatBuffersPackage;
import maxim.zaks.flatBuffers.Namespace;
import maxim.zaks.flatBuffers.RootType;
import maxim.zaks.flatBuffers.Schema;
import maxim.zaks.flatBuffers.Table;
import maxim.zaks.flatBuffers.TableType;
import maxim.zaks.flatBuffers.Type;
import maxim.zaks.flatBuffers.Vector;
import maxim.zaks.services.FlatBuffersGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class FlatBuffersSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private FlatBuffersGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == FlatBuffersPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case FlatBuffersPackage.ATTRIBUTE_NAME:
				sequence_AttributeName(context, (AttributeName) semanticObject); 
				return; 
			case FlatBuffersPackage.CUSTOM_ATTRIBUTES:
				sequence_CustomAttributes(context, (CustomAttributes) semanticObject); 
				return; 
			case FlatBuffersPackage.FIELD_ATTRIBUTES:
				sequence_FieldAttributes(context, (FieldAttributes) semanticObject); 
				return; 
			case FlatBuffersPackage.FIELDS:
				sequence_Fields(context, (Fields) semanticObject); 
				return; 
			case FlatBuffersPackage.NAMESPACE:
				sequence_Namespace(context, (Namespace) semanticObject); 
				return; 
			case FlatBuffersPackage.ROOT_TYPE:
				sequence_RootType(context, (RootType) semanticObject); 
				return; 
			case FlatBuffersPackage.SCHEMA:
				sequence_Schema(context, (Schema) semanticObject); 
				return; 
			case FlatBuffersPackage.TABLE:
				sequence_Table(context, (Table) semanticObject); 
				return; 
			case FlatBuffersPackage.TABLE_TYPE:
				sequence_TableType(context, (TableType) semanticObject); 
				return; 
			case FlatBuffersPackage.TYPE:
				sequence_Type(context, (Type) semanticObject); 
				return; 
			case FlatBuffersPackage.VECTOR:
				sequence_Vector(context, (Vector) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (deprectated?='deprecated' | customName=[CustomAttributes|ID])
	 */
	protected void sequence_AttributeName(EObject context, AttributeName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_CustomAttributes(EObject context, CustomAttributes semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, FlatBuffersPackage.Literals.CUSTOM_ATTRIBUTES__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FlatBuffersPackage.Literals.CUSTOM_ATTRIBUTES__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getCustomAttributesAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (attributeList='(' atributeName+=AttributeName*)
	 */
	protected void sequence_FieldAttributes(EObject context, FieldAttributes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID type=Type defaultValue=Value? attributes=FieldAttributes?)
	 */
	protected void sequence_Fields(EObject context, Fields semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=QualifiedName
	 */
	protected void sequence_Namespace(EObject context, Namespace semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, FlatBuffersPackage.Literals.NAMESPACE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FlatBuffersPackage.Literals.NAMESPACE__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getNamespaceAccess().getNameQualifiedNameParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     type=[Table|ID]
	 */
	protected void sequence_RootType(EObject context, RootType semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, FlatBuffersPackage.Literals.ROOT_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FlatBuffersPackage.Literals.ROOT_TYPE__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRootTypeAccess().getTypeTableIDTerminalRuleCall_1_0_1(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         includes+=Include* 
	 *         namepsace=Namespace? 
	 *         fileIdentifier=FileIdentifier? 
	 *         customAttributes+=CustomAttributes* 
	 *         tables+=Table* 
	 *         rootType=RootType
	 *     )
	 */
	protected void sequence_Schema(EObject context, Schema semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     type=[Table|ID]
	 */
	protected void sequence_TableType(EObject context, TableType semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, FlatBuffersPackage.Literals.TABLE_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FlatBuffersPackage.Literals.TABLE_TYPE__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTableTypeAccess().getTypeTableIDTerminalRuleCall_0_1(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID fields+=Fields*)
	 */
	protected void sequence_Table(EObject context, Table semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (primType=Primitive | vectorType=Vector | tableType=TableType)
	 */
	protected void sequence_Type(EObject context, Type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (primType=Primitive | tableType=TableType)
	 */
	protected void sequence_Vector(EObject context, Vector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
