/*
 * generated by Xtext
 */
package maxim.zaks.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import maxim.zaks.flatBuffers.AttributeName;
import maxim.zaks.flatBuffers.CustomAttributes;
import maxim.zaks.flatBuffers.EnumCase;
import maxim.zaks.flatBuffers.FieldAttributes;
import maxim.zaks.flatBuffers.Fields;
import maxim.zaks.flatBuffers.FlatBuffersPackage;
import maxim.zaks.flatBuffers.Namespace;
import maxim.zaks.flatBuffers.RootType;
import maxim.zaks.flatBuffers.Schema;
import maxim.zaks.flatBuffers.Struct;
import maxim.zaks.flatBuffers.StructFields;
import maxim.zaks.flatBuffers.Table;
import maxim.zaks.flatBuffers.Type;
import maxim.zaks.flatBuffers.Union;
import maxim.zaks.flatBuffers.Value;
import maxim.zaks.flatBuffers.Vector;
import maxim.zaks.services.FlatBuffersGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class FlatBuffersSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private FlatBuffersGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == FlatBuffersPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case FlatBuffersPackage.ATTRIBUTE_NAME:
				sequence_AttributeName(context, (AttributeName) semanticObject); 
				return; 
			case FlatBuffersPackage.CUSTOM_ATTRIBUTES:
				sequence_CustomAttributes(context, (CustomAttributes) semanticObject); 
				return; 
			case FlatBuffersPackage.ENUM:
				sequence_Enum(context, (maxim.zaks.flatBuffers.Enum) semanticObject); 
				return; 
			case FlatBuffersPackage.ENUM_CASE:
				sequence_EnumCase(context, (EnumCase) semanticObject); 
				return; 
			case FlatBuffersPackage.FIELD_ATTRIBUTES:
				sequence_FieldAttributes(context, (FieldAttributes) semanticObject); 
				return; 
			case FlatBuffersPackage.FIELDS:
				sequence_Fields(context, (Fields) semanticObject); 
				return; 
			case FlatBuffersPackage.NAMESPACE:
				sequence_Namespace(context, (Namespace) semanticObject); 
				return; 
			case FlatBuffersPackage.ROOT_TYPE:
				sequence_RootType(context, (RootType) semanticObject); 
				return; 
			case FlatBuffersPackage.SCHEMA:
				sequence_Schema(context, (Schema) semanticObject); 
				return; 
			case FlatBuffersPackage.STRUCT:
				sequence_Struct(context, (Struct) semanticObject); 
				return; 
			case FlatBuffersPackage.STRUCT_FIELDS:
				sequence_StructFields(context, (StructFields) semanticObject); 
				return; 
			case FlatBuffersPackage.TABLE:
				sequence_Table(context, (Table) semanticObject); 
				return; 
			case FlatBuffersPackage.TYPE:
				sequence_Type(context, (Type) semanticObject); 
				return; 
			case FlatBuffersPackage.UNION:
				sequence_Union(context, (Union) semanticObject); 
				return; 
			case FlatBuffersPackage.VALUE:
				sequence_Value(context, (Value) semanticObject); 
				return; 
			case FlatBuffersPackage.VECTOR:
				sequence_Vector(context, (Vector) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (
	 *         deprectated?=DEPRECTED_ATTRIBUTE | 
	 *         (hasAttributeId?=ID_ATTRIBUTE attributeId=INT) | 
	 *         required?=REQUIRED_ATTRIBUTE | 
	 *         original_order?='original_order' | 
	 *         (hasAlignSize?='force_align' alignSize=INT) | 
	 *         (hasHash?=HASH_ATTRIBUTE hashKey=STRING) | 
	 *         bit_flags?='bit_flags' | 
	 *         (hasNestedTableName?='nested_flatbuffer' nestedTableName=STRING) | 
	 *         key?=KEY_ATTRIBUTE | 
	 *         (customName=[CustomAttributes|ID] (intValue=INT | stringValue=STRING)?)
	 *     )
	 */
	protected void sequence_AttributeName(EObject context, AttributeName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=STRING
	 */
	protected void sequence_CustomAttributes(EObject context, CustomAttributes semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, FlatBuffersPackage.Literals.CUSTOM_ATTRIBUTES__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FlatBuffersPackage.Literals.CUSTOM_ATTRIBUTES__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getCustomAttributesAccess().getNameSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID value=INT?)
	 */
	protected void sequence_EnumCase(EObject context, EnumCase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID type=PrimitiveNumberType? attributes=FieldAttributes? enumCases+=EnumCase enumCases+=EnumCase*)
	 */
	protected void sequence_Enum(EObject context, maxim.zaks.flatBuffers.Enum semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (atributeNames+=AttributeName atributeNames+=AttributeName*)
	 */
	protected void sequence_FieldAttributes(EObject context, FieldAttributes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ValidID type=Type defaultValue=Value? attributes=FieldAttributes?)
	 */
	protected void sequence_Fields(EObject context, Fields semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=QualifiedName
	 */
	protected void sequence_Namespace(EObject context, Namespace semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, FlatBuffersPackage.Literals.NAMESPACE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FlatBuffersPackage.Literals.NAMESPACE__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getNamespaceAccess().getNameQualifiedNameParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     type=[Table|ID]
	 */
	protected void sequence_RootType(EObject context, RootType semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, FlatBuffersPackage.Literals.ROOT_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FlatBuffersPackage.Literals.ROOT_TYPE__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRootTypeAccess().getTypeTableIDTerminalRuleCall_1_0_1(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         includes+=Include* 
	 *         namepsace=Namespace? 
	 *         fileIdentifier=FileIdentifier? 
	 *         file_extension=FileExtension? 
	 *         customAttributes+=CustomAttributes* 
	 *         definitions+=Definition* 
	 *         rootType=RootType
	 *     )
	 */
	protected void sequence_Schema(EObject context, Schema semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID (primType=PrimitiveWithoutString | defType=[Definition|ID]))
	 */
	protected void sequence_StructFields(EObject context, StructFields semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID attributes=FieldAttributes? fields+=StructFields*)
	 */
	protected void sequence_Struct(EObject context, Struct semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID attributes=FieldAttributes? fields+=Fields*)
	 */
	protected void sequence_Table(EObject context, Table semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (primType=Primitive | vectorType=Vector | defType=[Definition|ID] | qualifiedType=QualifiedType)
	 */
	protected void sequence_Type(EObject context, Type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID unionCases+=[Table|ID] unionCases+=[Table|ID]*)
	 */
	protected void sequence_Union(EObject context, Union semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (number=Number | isFalse?='false' | isTrue?='true' | enumCase=ID)
	 */
	protected void sequence_Value(EObject context, Value semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     type=Type
	 */
	protected void sequence_Vector(EObject context, Vector semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, FlatBuffersPackage.Literals.VECTOR__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FlatBuffersPackage.Literals.VECTOR__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getVectorAccess().getTypeTypeParserRuleCall_1_0(), semanticObject.getType());
		feeder.finish();
	}
}
